---
title: "EslintSortObjectKeys : Une extension ESLint pour imposer l'ordre des cl√©s d'objet personnalis√©es"
publishedAt: "2025-02-19"
summary: "D√©couverte d'une extension ESLint maison qui permet de garantir un ordre coh√©rent et personnalisable des cl√©s d'objet dans le code TypeScript."
tags:
- ESLint
- TypeScript
- Linter
- Quality
- Open Source
shortTitle: EslintSortObjectKeys
---

## Pourquoi ai-je d√©marr√© ce projet ?

Dans mon entreprise, nous avions souvent des divergences sur l'ordre des propri√©t√©s des objets dans le code TypeScript.

Cela compliquait la lecture, les PRs, et rendait les diff inutiles bruyants. Aucun plugin ESLint n'√©tait capable de r√©pondre pleinement √† notre besoin :

- Avoir un ordre personnalisable d√©fini selon le type de l'objet,
- Supporter les structures imbriqu√©es,
- Permettre de configurer des sous-ordres pour les enfants.

C'est ainsi qu'est n√© **`@hacksis/eslint-plugin-sort-object-keys`**, une r√®gle ESLint sp√©cifique que j'ai d√©velopp√©e et que nous utilisons en production.

## Fonctionnement g√©n√©ral

L'extension ajoute une r√®gle ESLint personnalis√©e `sort-object-keys` qui v√©rifie l'ordre des cl√©s des objets selon un sch√©ma pr√©d√©fini.

Elle repose sur deux concepts cl√©s :

1. **Comparaison d'ordre attendu** : on compare l'ordre effectif des propri√©t√©s avec l'ordre attendu.
2. **Support des structures imbriqu√©es** : la v√©rification est r√©cursive sur les objets enfants.

## API et interfaces cl√©s

### 1. Interfaces de configuration

```typescript
export interface RuleOptions {
    typeName: string;
    order: (string | RuleSubOptions)[];
    children?: string;
}

export interface RuleSubOptions {
    typeName: string;
    order: (string | RuleSubOptions)[];
}

export type MessageIds = 'incorrectOrder';
```

### 2. Comparaison des tableaux : `areArraysEqual`

Permet de comparer deux tableaux de cl√©s :

```typescript
export function areArraysEqual(array1: string[], array2: string[]): boolean {
    if (array1.length !== array2.length) return false;
    for (let i = 0; i < array1.length; i++) {
        if (array1[i] !== array2[i]) return false;
    }
    return true;
}
```

### 3. R√©solution de l'ordre attendu : `resolveExpectedOrder`

Permet de g√©n√©rer dynamiquement l'ordre attendu des propri√©t√©s, en g√©rant les sous-ordres imbriqu√©s :

```typescript
export function resolveExpectedOrder(order: (string | RuleSubOptions)[]): string[] {
    const resolvedEntries = new Set<string>();
    order.forEach(entry => {
        if (typeof entry === 'string') {
            resolvedEntries.add(entry);
        } else {
            resolvedEntries.add(entry.typeName);
            resolveExpectedOrder(entry.order).forEach(subEntry => resolvedEntries.add(subEntry));
        }
    });
    return Array.from(resolvedEntries);
}
```

## Int√©gration dans la r√®gle ESLint

La m√©thode cl√© est `checkObjectOrder`, qui :

* R√©cup√®re les propri√©t√©s pr√©sentes dans l'objet,
* Les compare √† l'ordre attendu,
* G√©n√®re un report si l'ordre n'est pas respect√©,
* G√®re les structures imbriqu√©es et les tableaux d'enfants.

Exemple simplifi√© :

```typescript
function checkObjectOrder(node, parentTypeName, typeName, expectedOrder, childrenKey) {
    const resolvedOrder = resolveExpectedOrder(expectedOrder);
    const actualKeys = node.properties
        .filter(prop => prop.type === 'Property' && prop.key.type === 'Identifier')
        .map(prop => prop.key.name)
        .filter(key => resolvedOrder.includes(key));

    const filteredExpectedOrder = resolvedOrder.filter(key => actualKeys.includes(key));

    if (actualKeys.length > 1 && !areArraysEqual(filteredExpectedOrder, actualKeys)) {
        context.report({
            node,
            messageId: 'incorrectOrder',
            data: { typeName, parentTypeName, expectedOrder: filteredExpectedOrder.join(', ') }
        });
    }

    // Gestion r√©cursive des sous-objets...
}
```

## Cas d'usage typique

Exemple de configuration ESLint :

```json
"rules": {
    "@hacksis/sort-object-keys": ["error", [
        {
            "typeName": "User",
            "order": ["id", "name", "email", {
                "typeName": "address",
                "order": ["street", "city", "zip"]
            }]
        }
    ]]
}
```

Ce qui garantit que :

```typescript
const user: User = {
    id: 1,
    name: 'John',
    email: 'john@example.com',
    address: {
        street: '123 Main St',
        city: 'Paris',
        zip: '75001'
    }
};
```

respectera toujours l'ordre attendu.

Stack de dev :

* TypeScript 5.7+
* ESLint 9.20+
* Vitest pour les tests

## Finalit√©

Ce projet r√©pond parfaitement √† notre besoin en interne :

* Conventions homog√®nes dans les projets,
* Lisibilit√© am√©lior√©e,
* R√©duction des conflits de merge,
* Contr√¥le avanc√© des structures imbriqu√©es.

Pour le moment, nous testons le plugin en interne afin de valider son bon fonctionnement. 
Une fois cette phase termin√©e, je le transf√©rerai sur mon d√©p√¥t personnel et le publierai officiellement sur les registres de packages (npm, yarn) pour qu'il soit accessible √† tous.

Bonne automatisation du code üöÄ !